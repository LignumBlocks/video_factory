## T-103 — BeatSegmenterAgent (script → beat_sheet.jsonl) — **EXPANDIDO (implementable)**

**Objetivo:** convertir el guion en una lista **estructurada, auditada y estable** de beats (unidades narrativas), sin inventar visuales.  
**Resultado:** `beat_sheet.jsonl` listo para alimentar al `VisualPlannerAgent`.

> **Decisión cerrada:** BeatSegmenter NO decide cámara, colores, estilo visual ni escenas. Solo segmenta narrativa y expresa intención.

---

### T-103.0 — Entradas / Salidas / Ubicaciones (paths obligatorios)

#### Inputs (del RUN)
- `runs/<run_id>/inputs/script.txt` (o `.md`)  
- `runs/<run_id>/inputs/style_bible_LOCKED.md` (solo para reglas narrativas/tono, si aplica)
- (Opcional) `runs/<run_id>/work/normalized_script.txt` si existe; si no, usar `inputs/script.*`

#### Output principal
- `runs/<run_id>/work/beats/beat_sheet.jsonl`

#### Outputs secundarios (recomendados)
- `runs/<run_id>/work/beats/beat_sheet.meta.json` (estadísticas y warnings)
- `runs/<run_id>/work/beats/beat_segmenter_prompt.txt` (solo si `DEBUG_PROMPTS=true`)

---

### T-103.1 — Contrato de datos (lo que debe producir)

#### JSONL por línea (schema final por beat)
Cada línea del JSONL debe ser un objeto con **campos requeridos**:

```json
{
  "run_id": "20260209_101530_ab12cd34",
  "beat_id": "b001",
  "order": 1,
  "text": "Texto exacto del beat (tal cual del guion, sin agregar ideas nuevas).",
  "intent": "Intención narrativa breve (por qué existe este beat).",
  "estimated_seconds": 4.0,
  "priority": 1,
  "source": {
    "line_start": 12,
    "line_end": 18
  },
  "agent_version": "BeatSegmenter/1.0",
  "created_at": "2026-02-09T10:15:30-05:00"
}
```

**Notas:**
- `order` es obligatorio para ordenar beats de forma determinística.
- `source.line_start/line_end` es obligatorio para trazabilidad (líneas del script normalizado).
- `text` debe ser una **subcadena** del guion (no reescritura creativa).

---

### T-103.2 — Reglas y restricciones (enforcement)

#### R1 — Estabilidad de IDs
- `beat_id` se asigna **por orden** después de validar/sanitizar:
  - `b001`, `b002`, …, `bNNN`
- `beat_id` NO viene del LLM (para evitar drift).

#### R2 — Prohibición de visuales
- Está prohibido que BeatSegmenter incluya:
  - instrucciones de cámara
  - colores/paleta
  - “vemos X”, “aparece X”
  - referencias a estilo visual (neon, glossy, etc.)
- Si se detecta (regex simple de keywords) → warning en meta; si supera umbral → FAIL con `BEAT_VISUAL_CONTAMINATION`.

#### R3 — Conteo de beats (configurable)
- Defaults recomendados (si no existe config):
  - `min_beats = 6`
  - `max_beats = 18`
- Si salen menos de `min_beats` o más de `max_beats`:
  - intentar post-proceso (merge/split) **1 vez**
  - si sigue fuera → FAIL `BEAT_COUNT_OUT_OF_RANGE`

#### R4 — Duración estimada
- `estimated_seconds` puede ser aproximado.
- Debe ser float entre:
  - `min_sec = 1.0`
  - `max_sec = 12.0`
- Valores fuera → clamp + warning (no romper), excepto si hay demasiados fuera (umbral configurable).

#### R5 — Beats vacíos
- No se permiten beats con `text` vacío o solo whitespace.
- Se filtran; si quedan 0 beats → FAIL `EMPTY_BEAT_SHEET`.

---

### T-103.3 — Algoritmo (paso a paso, exacto)

#### Paso A — Preparar script con numeración de líneas
1) Cargar `normalized_script.txt` si existe; si no, leer `inputs/script.*` y normalizar:
   - convertir CRLF → LF
   - trim espacios al final de línea
   - colapsar más de 2 líneas en blanco a 2
2) Generar un arreglo `lines[]` con índice 1-based.
3) Guardar `work/normalized_script.txt` (si no existía).

#### Paso B — Construir request al LLM (JSON strict)
1) Construir mensajes:
   - `system`: reglas duras (NO visuales, devolver JSON, no inventar texto, etc.)
   - `user`: script con números de línea + instrucciones + límites (min/max beats)
2) Llamar a `llm.generate_json(req)` usando `LLMJsonRequest`.

**Schema que el LLM debe cumplir (JSON Schema-like)**
```json
{
  "type": "object",
  "required": ["beats"],
  "properties": {
    "beats": {
      "type": "array",
      "minItems": 1,
      "items": {
        "type": "object",
        "required": ["order","line_start","line_end","intent","estimated_seconds","priority"],
        "properties": {
          "order": {"type":"integer","minimum":1},
          "line_start": {"type":"integer","minimum":1},
          "line_end": {"type":"integer","minimum":1},
          "intent": {"type":"string","minLength":3},
          "estimated_seconds": {"type":"number","minimum":1.0,"maximum":12.0},
          "priority": {"type":"integer","minimum":1,"maximum":3}
        }
      }
    }
  }
}
```

> **Importante:** El LLM NO devuelve `text`. Devuelve rangos de líneas (`line_start`, `line_end`). El sistema arma `text` cortando el script.  
> Esto hace el resultado **a prueba de “inventos”**.

#### Paso C — Post-proceso determinístico (sin LLM)
1) Ordenar beats por `order`.
2) Validar rangos:
   - `1 <= line_start <= line_end <= len(lines)`
   - sin rangos vacíos
3) Construir `text` concatenando `lines[line_start:line_end]` con `\n`.
4) Aplicar merge de beats muy cortos:
   - si `estimated_seconds < 1.5` o `len(text) < 40` → merge con el siguiente (solo 1 pasada)
5) Recalcular `order` y asignar `beat_id` por índice.
6) Detectar contaminación visual (keywords) en `intent` y `text`:
   - si hay > X ocurrencias → FAIL `BEAT_VISUAL_CONTAMINATION`
7) Escribir `beat_sheet.jsonl` (1 objeto por línea) con metadata.

#### Paso D — Meta + manifest
- Escribir `beat_sheet.meta.json` con:
  - `total_beats`
  - `avg_estimated_seconds`
  - warnings (lista)
  - `min_beats/max_beats` usados
- Registrar Step en `run_manifest.json`:
  - step `BEAT_SEGMENTER`
  - status SUCCESS/FAIL
  - artifacts: `beat_sheet.jsonl`, `beat_sheet.meta.json`

---

### T-103.4 — Prompt exacto (plantilla) para BeatSegmenter

#### System (ejemplo)
- “Eres un segmentador narrativo…”
- “NO describas visuales, cámara, colores ni escenas.”
- “No inventes texto; solo usa rangos de líneas del guion.”
- “Responde SOLO con JSON válido que cumpla el schema.”

#### User (ejemplo)
Incluye:
- límites: `min_beats`, `max_beats`
- guion con líneas numeradas
- objetivo: beats con intención

> El prompt exacto debe quedar en código como template con placeholders.

---

### T-103.5 — Errores estándar (error codes)

- `BEAT_SEGMENTATION_FAILED`  
  - el proveedor falla o devuelve error no recuperable
- `JSON_SCHEMA_VIOLATION`  
  - la respuesta JSON no cumple schema
- `BEAT_RANGE_INVALID`  
  - rangos de línea fuera de límites o inconsistentes
- `BEAT_COUNT_OUT_OF_RANGE`  
  - beats fuera de min/max después de 1 post-proceso
- `EMPTY_BEAT_SHEET`  
  - no quedó ningún beat usable
- `BEAT_VISUAL_CONTAMINATION`  
  - demasiadas señales de visuales/cámara/estilo en intent/text

---

### T-103.6 — Criterios de Aceptación (AC)

1) `work/beats/beat_sheet.jsonl` existe y es JSONL válido (una línea = un JSON).
2) Cada beat tiene `run_id`, `beat_id`, `order`, `text`, `intent`, `estimated_seconds`, `priority`, `source.line_start/line_end`.
3) `text` se obtiene **exclusivamente** del script (por rangos de línea). No hay texto inventado.
4) El step queda registrado en `run_manifest.json` con artifacts.
5) El comportamiento es determinístico con `MockLLMClient` (mismo input → mismo output).

---

### T-103.7 — Tests obligatorios (detallados)

#### Unit
- `test_ranges_build_text_from_lines()`
- `test_assigns_stable_beat_ids_after_sorting()`
- `test_merge_short_beats_once()`
- `test_visual_contamination_detection()`

#### JSON schema / validation
- `test_llm_json_schema_violation_raises()`
- `test_invalid_ranges_fail()`

#### Integration (sin red)
- `test_beat_segmenter_produces_jsonl_with_mock_llm()`

#### Fixtures requeridas
- `tests/fixtures/scripts/script_short.txt`
- `tests/fixtures/llm/beat_segmenter_response.json`

---

### T-103.8 — Notas de implementación
- Este ticket depende de `LLMClient` (T-102).
- Recomendación: agregar en `system_rules.yaml -> agent_settings.beat_segmenter`:
  - `min_beats`, `max_beats`, `visual_contamination_threshold`

---
