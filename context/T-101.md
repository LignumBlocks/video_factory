# Hito 2 — Tickets de implementación (Agents Layer) — v1.1 (con T-101 expandido)

> Este hito implementa los steps:  
> `BEAT_SEGMENTER` → `VISUAL_PLANNER` → `PROMPT_PACK` (+ `PROMPT_SANITIZER`)  
> Integrado al `Step Runner` del Hito 1.

---

## T-101 — Config: Shot Menu y reglas del sistema (EXPANDIDO y listo para implementar)

**Objetivo:** tener un “menú cerrado” (Shot Menu) y reglas del sistema versionadas, validadas y **congeladas por RUN** para evitar deriva.

### T-101.0 — Decisiones cerradas
- Formato recomendado: **YAML** (más legible para humanos) pero se acepta JSON si prefieren.  
- Ubicación canónica en repo:
  - `config/shot_menu.yaml`
  - `config/system_rules.yaml`
- Regla anti-deriva: al crear RUN se copian configs a:
  - `runs/<run_id>/inputs/config/shot_menu.yaml`
  - `runs/<run_id>/inputs/config/system_rules.yaml`
  y a partir de ahí el RUN usa **solo** esas copias.

### T-101.1 — Shot Menu: schema mínimo + ejemplo completo

#### Archivo: `config/shot_menu.yaml`
**Schema mínimo (campos requeridos)**
- `schema_version` (string, ej. `"1.0"`)
- `menu_id` (string, ej. `"clean_score_jump_v1"`)
- `shot_types` (lista)
  - cada `shot_type` requiere:
    - `id` (UPPER_SNAKE_CASE, único)
    - `description` (string)
    - `prompt_hints` (dict con hints para PromptBuilder; no son prompts finales)
    - `constraints` (dict con banderas)
    - `allowed` (dict con enums permitidos por shot)

**Ejemplo implementable**
```yaml
schema_version: "1.0"
menu_id: "clean_score_jump_v1"
shot_types:
  - id: "SCORE_JUMP"
    description: "Momento de subida de score: energía concentrada, 'surge' limpio dentro de sistema cerrado."
    allowed:
      energy: ["high", "med"]
      camera: ["locked", "slow_push"]
    constraints:
      allow_amber: false
      allow_particles: true
      allow_text_like_shapes: false
    prompt_hints:
      visuals:
        - "energy surge inside a closed system"
        - "score increase moment expressed abstractly"
      motion:
        - "smooth controlled motion"
      composition:
        - "center-focused, minimal clutter"

  - id: "UNLOCK_REVEAL"
    description: "Revelación de 'unlock': único lugar donde se permite 'amber' (si biblia lo define)."
    allowed:
      energy: ["med", "high"]
      camera: ["locked", "slow_orbit"]
    constraints:
      allow_amber: true
      allow_particles: true
      allow_text_like_shapes: false
    prompt_hints:
      visuals:
        - "unlock moment with subtle reveal"
        - "amber accent allowed only here"
      motion:
        - "slow orbit or slow push"
      composition:
        - "clean silhouette-like shapes (non-human)"

  - id: "CIRCUIT_FLOW"
    description: "Flujo de circuito/fluido abstracto dentro de contenedor sellado (no leaks)."
    allowed:
      energy: ["low", "med"]
      camera: ["locked"]
    constraints:
      allow_amber: false
      allow_particles: false
      allow_text_like_shapes: false
    prompt_hints:
      visuals:
        - "closed-loop circuit flow"
        - "sealed container, no spilling"
      motion:
        - "gentle flow"
      composition:
        - "macro detail, glossy surfaces"
```

#### Reglas de validación (enforcement)
- `shot_types[].id`:
  - único, no repetido
  - regex: `^[A-Z][A-Z0-9_]{2,32}$`
- `allowed.energy` solo permite: `low|med|high`
- `allowed.camera` solo permite valores definidos por sistema (ver `system_rules.yaml`)
- Si `constraints.allow_amber=true`, debe existir una regla en `system_rules.yaml` que defina **en qué evento/shot** se permite.

---

### T-101.2 — System Rules: schema mínimo + ejemplo completo

#### Archivo: `config/system_rules.yaml`
**Schema mínimo (campos requeridos)**
- `schema_version`
- `run_mode_defaults`
- `durations`
- `guardrails`
- `models`
- `agent_settings`

**Ejemplo implementable**
```yaml
schema_version: "1.0"

run_mode_defaults:
  duration_s_default: 8
  duration_policy: "fixed"   # fixed | variable (variable requiere CR)
  edit_window_s_default: 4   # tramo usable del clip para rough cut

durations:
  clip_min_s: 8
  clip_max_s: 8
  enforce_exact: true

guardrails:
  required_negative_terms:
    - "humans"
    - "hands"
    - "faces"
    - "text"
    - "letters"
    - "numbers"
    - "logos"
    - "watermark"
    - "signage"
    - "qr code"
  forbidden_prompt_terms:
    - "add text"
    - "show text"
    - "caption"
    - "subtitle"
    - "logo"
    - "brand name"
  amber_rule:
    enabled: true
    allowed_only_in_shot_types: ["UNLOCK_REVEAL"]
  closed_system_rule:
    enabled: true
    enforce_terms:
      - "closed system"
      - "sealed"
      - "no leaks"

models:
  video:
    target: "veo"
    fps: 30
    aspect_ratio: "9:16"
    duration_s: 8
  init_frame:
    enabled: true
    target: "nanobanana"

agent_settings:
  beat_segmenter:
    provider: "openai"
    model: "gpt-4.1-mini"
    temperature: 0.2
    max_tokens: 1200
  visual_planner:
    provider: "openai"
    model: "gpt-4.1-mini"
    temperature: 0.3
    max_tokens: 1400
  prompt_builder:
    provider: "openai"
    model: "gpt-4.1-mini"
    temperature: 0.2
    max_tokens: 1600
  prompt_sanitizer:
    mode: "rules_first"   # rules_first | llm_assisted (llm_assisted requiere CR)
```

#### Reglas de validación (enforcement)
- Si `durations.enforce_exact=true` entonces:
  - `clip_min_s == clip_max_s == run_mode_defaults.duration_s_default`
- `guardrails.required_negative_terms` no puede estar vacío.
- Si `amber_rule.enabled=true`:
  - `allowed_only_in_shot_types` debe tener al menos 1 elemento.
- `models.video.target` y `models.init_frame.target` deben pertenecer a una lista permitida (defínela en código).

---

### T-101.3 — Código requerido (cómo implementarlo)

#### A) Modelos de validación (Pydantic recomendado)
- Crear `videofactory/config/models.py` con:
  - `ShotMenuConfig`, `ShotType`
  - `SystemRulesConfig`, `Guardrails`, `ModelVideo`, `AgentSettings`, etc.
- Crear `videofactory/config/loader.py` con:
  - `load_shot_menu(path) -> ShotMenuConfig`
  - `load_system_rules(path) -> SystemRulesConfig`
  - soporte YAML/JSON.

#### B) Congelado de config por RUN
- En `create-run`:
  - copiar `config/shot_menu.yaml` y `config/system_rules.yaml` a `runs/<run_id>/inputs/config/`
  - agregar a `run_manifest.json`:
    - `config.shot_menu.sha256`
    - `config.system_rules.sha256`
    - `config.menu_id`, `schema_version`
- En `execute-run`:
  - cargar **desde el RUN** (no desde repo).

#### C) API de consulta en runtime
- Exponer helpers:
  - `get_shot_type(shot_id)` → ShotType
  - `validate_shot_type(shot_id)` → raise `SHOT_MENU_VIOLATION`

---

### T-101.4 — Errores estándar (error codes)
- `FAILED_CONFIG`:
  - config file missing
  - YAML parse error
  - schema invalid
- `SHOT_MENU_VIOLATION`:
  - VisualPlanner produce `shot_type` inexistente
- `RULES_CONTRADICTION`:
  - duration_policy contradictoria
  - amber_rule enabled sin `allowed_only_in_shot_types`

---

### T-101.5 — Criterios de Aceptación (AC)
1) `execute-run` carga configs desde `runs/<run_id>/inputs/config/` y valida schema.
2) Si config inválida → `FAILED_CONFIG` y RUN no avanza.
3) Config hashes quedan registrados en `run_manifest.json`.
4) VisualPlanner no puede producir `shot_type` fuera del menú; si lo hace → step FAIL con `SHOT_MENU_VIOLATION`.

---

### T-101.6 — Tests obligatorios
- Unit: `load_shot_menu_valid_yaml`
- Unit: `load_system_rules_valid_yaml`
- Unit: `duplicate_shot_id_fails`
- Unit: `invalid_shot_id_regex_fails`
- Unit: `duration_contradiction_fails`
- Integration: `create-run` copia configs y guarda hashes en manifest

---

## (Resto de tickets)
> Nota: el resto de tickets del Hito 2 permanecen igual que en la versión anterior, salvo que ahora dependen de estas configs validadas y congeladas por RUN.

---
